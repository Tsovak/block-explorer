package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/insolar/block-explorer/etl/types"
)

// TransformerMock implements interfaces.Transformer
type TransformerMock struct {
	t minimock.Tester

	funcGetJetDropsChannel          func() (ch1 <-chan *types.JetDrop)
	inspectFuncGetJetDropsChannel   func()
	afterGetJetDropsChannelCounter  uint64
	beforeGetJetDropsChannelCounter uint64
	GetJetDropsChannelMock          mTransformerMockGetJetDropsChannel

	funcStart          func(ctx context.Context) (err error)
	inspectFuncStart   func(ctx context.Context)
	afterStartCounter  uint64
	beforeStartCounter uint64
	StartMock          mTransformerMockStart

	funcStop          func(ctx context.Context) (err error)
	inspectFuncStop   func(ctx context.Context)
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mTransformerMockStop
}

// NewTransformerMock returns a mock for interfaces.Transformer
func NewTransformerMock(t minimock.Tester) *TransformerMock {
	m := &TransformerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetJetDropsChannelMock = mTransformerMockGetJetDropsChannel{mock: m}

	m.StartMock = mTransformerMockStart{mock: m}
	m.StartMock.callArgs = []*TransformerMockStartParams{}

	m.StopMock = mTransformerMockStop{mock: m}
	m.StopMock.callArgs = []*TransformerMockStopParams{}

	return m
}

type mTransformerMockGetJetDropsChannel struct {
	mock               *TransformerMock
	defaultExpectation *TransformerMockGetJetDropsChannelExpectation
	expectations       []*TransformerMockGetJetDropsChannelExpectation
}

// TransformerMockGetJetDropsChannelExpectation specifies expectation struct of the Transformer.GetJetDropsChannel
type TransformerMockGetJetDropsChannelExpectation struct {
	mock *TransformerMock

	results *TransformerMockGetJetDropsChannelResults
	Counter uint64
}

// TransformerMockGetJetDropsChannelResults contains results of the Transformer.GetJetDropsChannel
type TransformerMockGetJetDropsChannelResults struct {
	ch1 <-chan *types.JetDrop
}

// Expect sets up expected params for Transformer.GetJetDropsChannel
func (mmGetJetDropsChannel *mTransformerMockGetJetDropsChannel) Expect() *mTransformerMockGetJetDropsChannel {
	if mmGetJetDropsChannel.mock.funcGetJetDropsChannel != nil {
		mmGetJetDropsChannel.mock.t.Fatalf("TransformerMock.GetJetDropsChannel mock is already set by Set")
	}

	if mmGetJetDropsChannel.defaultExpectation == nil {
		mmGetJetDropsChannel.defaultExpectation = &TransformerMockGetJetDropsChannelExpectation{}
	}

	return mmGetJetDropsChannel
}

// Inspect accepts an inspector function that has same arguments as the Transformer.GetJetDropsChannel
func (mmGetJetDropsChannel *mTransformerMockGetJetDropsChannel) Inspect(f func()) *mTransformerMockGetJetDropsChannel {
	if mmGetJetDropsChannel.mock.inspectFuncGetJetDropsChannel != nil {
		mmGetJetDropsChannel.mock.t.Fatalf("Inspect function is already set for TransformerMock.GetJetDropsChannel")
	}

	mmGetJetDropsChannel.mock.inspectFuncGetJetDropsChannel = f

	return mmGetJetDropsChannel
}

// Return sets up results that will be returned by Transformer.GetJetDropsChannel
func (mmGetJetDropsChannel *mTransformerMockGetJetDropsChannel) Return(ch1 <-chan *types.JetDrop) *TransformerMock {
	if mmGetJetDropsChannel.mock.funcGetJetDropsChannel != nil {
		mmGetJetDropsChannel.mock.t.Fatalf("TransformerMock.GetJetDropsChannel mock is already set by Set")
	}

	if mmGetJetDropsChannel.defaultExpectation == nil {
		mmGetJetDropsChannel.defaultExpectation = &TransformerMockGetJetDropsChannelExpectation{mock: mmGetJetDropsChannel.mock}
	}
	mmGetJetDropsChannel.defaultExpectation.results = &TransformerMockGetJetDropsChannelResults{ch1}
	return mmGetJetDropsChannel.mock
}

//Set uses given function f to mock the Transformer.GetJetDropsChannel method
func (mmGetJetDropsChannel *mTransformerMockGetJetDropsChannel) Set(f func() (ch1 <-chan *types.JetDrop)) *TransformerMock {
	if mmGetJetDropsChannel.defaultExpectation != nil {
		mmGetJetDropsChannel.mock.t.Fatalf("Default expectation is already set for the Transformer.GetJetDropsChannel method")
	}

	if len(mmGetJetDropsChannel.expectations) > 0 {
		mmGetJetDropsChannel.mock.t.Fatalf("Some expectations are already set for the Transformer.GetJetDropsChannel method")
	}

	mmGetJetDropsChannel.mock.funcGetJetDropsChannel = f
	return mmGetJetDropsChannel.mock
}

// GetJetDropsChannel implements interfaces.Transformer
func (mmGetJetDropsChannel *TransformerMock) GetJetDropsChannel() (ch1 <-chan *types.JetDrop) {
	mm_atomic.AddUint64(&mmGetJetDropsChannel.beforeGetJetDropsChannelCounter, 1)
	defer mm_atomic.AddUint64(&mmGetJetDropsChannel.afterGetJetDropsChannelCounter, 1)

	if mmGetJetDropsChannel.inspectFuncGetJetDropsChannel != nil {
		mmGetJetDropsChannel.inspectFuncGetJetDropsChannel()
	}

	if mmGetJetDropsChannel.GetJetDropsChannelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetJetDropsChannel.GetJetDropsChannelMock.defaultExpectation.Counter, 1)

		mm_results := mmGetJetDropsChannel.GetJetDropsChannelMock.defaultExpectation.results
		if mm_results == nil {
			mmGetJetDropsChannel.t.Fatal("No results are set for the TransformerMock.GetJetDropsChannel")
		}
		return (*mm_results).ch1
	}
	if mmGetJetDropsChannel.funcGetJetDropsChannel != nil {
		return mmGetJetDropsChannel.funcGetJetDropsChannel()
	}
	mmGetJetDropsChannel.t.Fatalf("Unexpected call to TransformerMock.GetJetDropsChannel.")
	return
}

// GetJetDropsChannelAfterCounter returns a count of finished TransformerMock.GetJetDropsChannel invocations
func (mmGetJetDropsChannel *TransformerMock) GetJetDropsChannelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDropsChannel.afterGetJetDropsChannelCounter)
}

// GetJetDropsChannelBeforeCounter returns a count of TransformerMock.GetJetDropsChannel invocations
func (mmGetJetDropsChannel *TransformerMock) GetJetDropsChannelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetJetDropsChannel.beforeGetJetDropsChannelCounter)
}

// MinimockGetJetDropsChannelDone returns true if the count of the GetJetDropsChannel invocations corresponds
// the number of defined expectations
func (m *TransformerMock) MinimockGetJetDropsChannelDone() bool {
	for _, e := range m.GetJetDropsChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropsChannelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsChannelCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDropsChannel != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsChannelCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetJetDropsChannelInspect logs each unmet expectation
func (m *TransformerMock) MinimockGetJetDropsChannelInspect() {
	for _, e := range m.GetJetDropsChannelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to TransformerMock.GetJetDropsChannel")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetJetDropsChannelMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsChannelCounter) < 1 {
		m.t.Error("Expected call to TransformerMock.GetJetDropsChannel")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetJetDropsChannel != nil && mm_atomic.LoadUint64(&m.afterGetJetDropsChannelCounter) < 1 {
		m.t.Error("Expected call to TransformerMock.GetJetDropsChannel")
	}
}

type mTransformerMockStart struct {
	mock               *TransformerMock
	defaultExpectation *TransformerMockStartExpectation
	expectations       []*TransformerMockStartExpectation

	callArgs []*TransformerMockStartParams
	mutex    sync.RWMutex
}

// TransformerMockStartExpectation specifies expectation struct of the Transformer.Start
type TransformerMockStartExpectation struct {
	mock    *TransformerMock
	params  *TransformerMockStartParams
	results *TransformerMockStartResults
	Counter uint64
}

// TransformerMockStartParams contains parameters of the Transformer.Start
type TransformerMockStartParams struct {
	ctx context.Context
}

// TransformerMockStartResults contains results of the Transformer.Start
type TransformerMockStartResults struct {
	err error
}

// Expect sets up expected params for Transformer.Start
func (mmStart *mTransformerMockStart) Expect(ctx context.Context) *mTransformerMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("TransformerMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &TransformerMockStartExpectation{}
	}

	mmStart.defaultExpectation.params = &TransformerMockStartParams{ctx}
	for _, e := range mmStart.expectations {
		if minimock.Equal(e.params, mmStart.defaultExpectation.params) {
			mmStart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStart.defaultExpectation.params)
		}
	}

	return mmStart
}

// Inspect accepts an inspector function that has same arguments as the Transformer.Start
func (mmStart *mTransformerMockStart) Inspect(f func(ctx context.Context)) *mTransformerMockStart {
	if mmStart.mock.inspectFuncStart != nil {
		mmStart.mock.t.Fatalf("Inspect function is already set for TransformerMock.Start")
	}

	mmStart.mock.inspectFuncStart = f

	return mmStart
}

// Return sets up results that will be returned by Transformer.Start
func (mmStart *mTransformerMockStart) Return(err error) *TransformerMock {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("TransformerMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &TransformerMockStartExpectation{mock: mmStart.mock}
	}
	mmStart.defaultExpectation.results = &TransformerMockStartResults{err}
	return mmStart.mock
}

//Set uses given function f to mock the Transformer.Start method
func (mmStart *mTransformerMockStart) Set(f func(ctx context.Context) (err error)) *TransformerMock {
	if mmStart.defaultExpectation != nil {
		mmStart.mock.t.Fatalf("Default expectation is already set for the Transformer.Start method")
	}

	if len(mmStart.expectations) > 0 {
		mmStart.mock.t.Fatalf("Some expectations are already set for the Transformer.Start method")
	}

	mmStart.mock.funcStart = f
	return mmStart.mock
}

// When sets expectation for the Transformer.Start which will trigger the result defined by the following
// Then helper
func (mmStart *mTransformerMockStart) When(ctx context.Context) *TransformerMockStartExpectation {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("TransformerMock.Start mock is already set by Set")
	}

	expectation := &TransformerMockStartExpectation{
		mock:   mmStart.mock,
		params: &TransformerMockStartParams{ctx},
	}
	mmStart.expectations = append(mmStart.expectations, expectation)
	return expectation
}

// Then sets up Transformer.Start return parameters for the expectation previously defined by the When method
func (e *TransformerMockStartExpectation) Then(err error) *TransformerMock {
	e.results = &TransformerMockStartResults{err}
	return e.mock
}

// Start implements interfaces.Transformer
func (mmStart *TransformerMock) Start(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStart.beforeStartCounter, 1)
	defer mm_atomic.AddUint64(&mmStart.afterStartCounter, 1)

	if mmStart.inspectFuncStart != nil {
		mmStart.inspectFuncStart(ctx)
	}

	mm_params := &TransformerMockStartParams{ctx}

	// Record call args
	mmStart.StartMock.mutex.Lock()
	mmStart.StartMock.callArgs = append(mmStart.StartMock.callArgs, mm_params)
	mmStart.StartMock.mutex.Unlock()

	for _, e := range mmStart.StartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStart.StartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStart.StartMock.defaultExpectation.Counter, 1)
		mm_want := mmStart.StartMock.defaultExpectation.params
		mm_got := TransformerMockStartParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStart.t.Errorf("TransformerMock.Start got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStart.StartMock.defaultExpectation.results
		if mm_results == nil {
			mmStart.t.Fatal("No results are set for the TransformerMock.Start")
		}
		return (*mm_results).err
	}
	if mmStart.funcStart != nil {
		return mmStart.funcStart(ctx)
	}
	mmStart.t.Fatalf("Unexpected call to TransformerMock.Start. %v", ctx)
	return
}

// StartAfterCounter returns a count of finished TransformerMock.Start invocations
func (mmStart *TransformerMock) StartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.afterStartCounter)
}

// StartBeforeCounter returns a count of TransformerMock.Start invocations
func (mmStart *TransformerMock) StartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.beforeStartCounter)
}

// Calls returns a list of arguments used in each call to TransformerMock.Start.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStart *mTransformerMockStart) Calls() []*TransformerMockStartParams {
	mmStart.mutex.RLock()

	argCopy := make([]*TransformerMockStartParams, len(mmStart.callArgs))
	copy(argCopy, mmStart.callArgs)

	mmStart.mutex.RUnlock()

	return argCopy
}

// MinimockStartDone returns true if the count of the Start invocations corresponds
// the number of defined expectations
func (m *TransformerMock) MinimockStartDone() bool {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartInspect logs each unmet expectation
func (m *TransformerMock) MinimockStartInspect() {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransformerMock.Start with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		if m.StartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransformerMock.Start")
		} else {
			m.t.Errorf("Expected call to TransformerMock.Start with params: %#v", *m.StartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && mm_atomic.LoadUint64(&m.afterStartCounter) < 1 {
		m.t.Error("Expected call to TransformerMock.Start")
	}
}

type mTransformerMockStop struct {
	mock               *TransformerMock
	defaultExpectation *TransformerMockStopExpectation
	expectations       []*TransformerMockStopExpectation

	callArgs []*TransformerMockStopParams
	mutex    sync.RWMutex
}

// TransformerMockStopExpectation specifies expectation struct of the Transformer.Stop
type TransformerMockStopExpectation struct {
	mock    *TransformerMock
	params  *TransformerMockStopParams
	results *TransformerMockStopResults
	Counter uint64
}

// TransformerMockStopParams contains parameters of the Transformer.Stop
type TransformerMockStopParams struct {
	ctx context.Context
}

// TransformerMockStopResults contains results of the Transformer.Stop
type TransformerMockStopResults struct {
	err error
}

// Expect sets up expected params for Transformer.Stop
func (mmStop *mTransformerMockStop) Expect(ctx context.Context) *mTransformerMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("TransformerMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &TransformerMockStopExpectation{}
	}

	mmStop.defaultExpectation.params = &TransformerMockStopParams{ctx}
	for _, e := range mmStop.expectations {
		if minimock.Equal(e.params, mmStop.defaultExpectation.params) {
			mmStop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStop.defaultExpectation.params)
		}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the Transformer.Stop
func (mmStop *mTransformerMockStop) Inspect(f func(ctx context.Context)) *mTransformerMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for TransformerMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by Transformer.Stop
func (mmStop *mTransformerMockStop) Return(err error) *TransformerMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("TransformerMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &TransformerMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &TransformerMockStopResults{err}
	return mmStop.mock
}

//Set uses given function f to mock the Transformer.Stop method
func (mmStop *mTransformerMockStop) Set(f func(ctx context.Context) (err error)) *TransformerMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the Transformer.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the Transformer.Stop method")
	}

	mmStop.mock.funcStop = f
	return mmStop.mock
}

// When sets expectation for the Transformer.Stop which will trigger the result defined by the following
// Then helper
func (mmStop *mTransformerMockStop) When(ctx context.Context) *TransformerMockStopExpectation {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("TransformerMock.Stop mock is already set by Set")
	}

	expectation := &TransformerMockStopExpectation{
		mock:   mmStop.mock,
		params: &TransformerMockStopParams{ctx},
	}
	mmStop.expectations = append(mmStop.expectations, expectation)
	return expectation
}

// Then sets up Transformer.Stop return parameters for the expectation previously defined by the When method
func (e *TransformerMockStopExpectation) Then(err error) *TransformerMock {
	e.results = &TransformerMockStopResults{err}
	return e.mock
}

// Stop implements interfaces.Transformer
func (mmStop *TransformerMock) Stop(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop(ctx)
	}

	mm_params := &TransformerMockStopParams{ctx}

	// Record call args
	mmStop.StopMock.mutex.Lock()
	mmStop.StopMock.callArgs = append(mmStop.StopMock.callArgs, mm_params)
	mmStop.StopMock.mutex.Unlock()

	for _, e := range mmStop.StopMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)
		mm_want := mmStop.StopMock.defaultExpectation.params
		mm_got := TransformerMockStopParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStop.t.Errorf("TransformerMock.Stop got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStop.StopMock.defaultExpectation.results
		if mm_results == nil {
			mmStop.t.Fatal("No results are set for the TransformerMock.Stop")
		}
		return (*mm_results).err
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop(ctx)
	}
	mmStop.t.Fatalf("Unexpected call to TransformerMock.Stop. %v", ctx)
	return
}

// StopAfterCounter returns a count of finished TransformerMock.Stop invocations
func (mmStop *TransformerMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of TransformerMock.Stop invocations
func (mmStop *TransformerMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// Calls returns a list of arguments used in each call to TransformerMock.Stop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStop *mTransformerMockStop) Calls() []*TransformerMockStopParams {
	mmStop.mutex.RLock()

	argCopy := make([]*TransformerMockStopParams, len(mmStop.callArgs))
	copy(argCopy, mmStop.callArgs)

	mmStop.mutex.RUnlock()

	return argCopy
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *TransformerMock) MinimockStopDone() bool {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		return false
	}
	return true
}

// MinimockStopInspect logs each unmet expectation
func (m *TransformerMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TransformerMock.Stop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		if m.StopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TransformerMock.Stop")
		} else {
			m.t.Errorf("Expected call to TransformerMock.Stop with params: %#v", *m.StopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && mm_atomic.LoadUint64(&m.afterStopCounter) < 1 {
		m.t.Error("Expected call to TransformerMock.Stop")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TransformerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetJetDropsChannelInspect()

		m.MinimockStartInspect()

		m.MinimockStopInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TransformerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TransformerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetJetDropsChannelDone() &&
		m.MinimockStartDone() &&
		m.MinimockStopDone()
}
