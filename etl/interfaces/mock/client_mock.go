package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"google.golang.org/grpc"
)

// ClientMock implements interfaces.Client
type ClientMock struct {
	t minimock.Tester

	funcGetGRPCConn          func() (cp1 *grpc.ClientConn)
	inspectFuncGetGRPCConn   func()
	afterGetGRPCConnCounter  uint64
	beforeGetGRPCConnCounter uint64
	GetGRPCConnMock          mClientMockGetGRPCConn

	funcNotifyShutdown func(ctx context.Context, stopChannel chan<- struct {
	}, waitForStateChange time.Duration)
	inspectFuncNotifyShutdown func(ctx context.Context, stopChannel chan<- struct {
	}, waitForStateChange time.Duration)
	afterNotifyShutdownCounter  uint64
	beforeNotifyShutdownCounter uint64
	NotifyShutdownMock          mClientMockNotifyShutdown
}

// NewClientMock returns a mock for interfaces.Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetGRPCConnMock = mClientMockGetGRPCConn{mock: m}

	m.NotifyShutdownMock = mClientMockNotifyShutdown{mock: m}
	m.NotifyShutdownMock.callArgs = []*ClientMockNotifyShutdownParams{}

	return m
}

type mClientMockGetGRPCConn struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetGRPCConnExpectation
	expectations       []*ClientMockGetGRPCConnExpectation
}

// ClientMockGetGRPCConnExpectation specifies expectation struct of the Client.GetGRPCConn
type ClientMockGetGRPCConnExpectation struct {
	mock *ClientMock

	results *ClientMockGetGRPCConnResults
	Counter uint64
}

// ClientMockGetGRPCConnResults contains results of the Client.GetGRPCConn
type ClientMockGetGRPCConnResults struct {
	cp1 *grpc.ClientConn
}

// Expect sets up expected params for Client.GetGRPCConn
func (mmGetGRPCConn *mClientMockGetGRPCConn) Expect() *mClientMockGetGRPCConn {
	if mmGetGRPCConn.mock.funcGetGRPCConn != nil {
		mmGetGRPCConn.mock.t.Fatalf("ClientMock.GetGRPCConn mock is already set by Set")
	}

	if mmGetGRPCConn.defaultExpectation == nil {
		mmGetGRPCConn.defaultExpectation = &ClientMockGetGRPCConnExpectation{}
	}

	return mmGetGRPCConn
}

// Inspect accepts an inspector function that has same arguments as the Client.GetGRPCConn
func (mmGetGRPCConn *mClientMockGetGRPCConn) Inspect(f func()) *mClientMockGetGRPCConn {
	if mmGetGRPCConn.mock.inspectFuncGetGRPCConn != nil {
		mmGetGRPCConn.mock.t.Fatalf("Inspect function is already set for ClientMock.GetGRPCConn")
	}

	mmGetGRPCConn.mock.inspectFuncGetGRPCConn = f

	return mmGetGRPCConn
}

// Return sets up results that will be returned by Client.GetGRPCConn
func (mmGetGRPCConn *mClientMockGetGRPCConn) Return(cp1 *grpc.ClientConn) *ClientMock {
	if mmGetGRPCConn.mock.funcGetGRPCConn != nil {
		mmGetGRPCConn.mock.t.Fatalf("ClientMock.GetGRPCConn mock is already set by Set")
	}

	if mmGetGRPCConn.defaultExpectation == nil {
		mmGetGRPCConn.defaultExpectation = &ClientMockGetGRPCConnExpectation{mock: mmGetGRPCConn.mock}
	}
	mmGetGRPCConn.defaultExpectation.results = &ClientMockGetGRPCConnResults{cp1}
	return mmGetGRPCConn.mock
}

//Set uses given function f to mock the Client.GetGRPCConn method
func (mmGetGRPCConn *mClientMockGetGRPCConn) Set(f func() (cp1 *grpc.ClientConn)) *ClientMock {
	if mmGetGRPCConn.defaultExpectation != nil {
		mmGetGRPCConn.mock.t.Fatalf("Default expectation is already set for the Client.GetGRPCConn method")
	}

	if len(mmGetGRPCConn.expectations) > 0 {
		mmGetGRPCConn.mock.t.Fatalf("Some expectations are already set for the Client.GetGRPCConn method")
	}

	mmGetGRPCConn.mock.funcGetGRPCConn = f
	return mmGetGRPCConn.mock
}

// GetGRPCConn implements interfaces.Client
func (mmGetGRPCConn *ClientMock) GetGRPCConn() (cp1 *grpc.ClientConn) {
	mm_atomic.AddUint64(&mmGetGRPCConn.beforeGetGRPCConnCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGRPCConn.afterGetGRPCConnCounter, 1)

	if mmGetGRPCConn.inspectFuncGetGRPCConn != nil {
		mmGetGRPCConn.inspectFuncGetGRPCConn()
	}

	if mmGetGRPCConn.GetGRPCConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGRPCConn.GetGRPCConnMock.defaultExpectation.Counter, 1)

		mm_results := mmGetGRPCConn.GetGRPCConnMock.defaultExpectation.results
		if mm_results == nil {
			mmGetGRPCConn.t.Fatal("No results are set for the ClientMock.GetGRPCConn")
		}
		return (*mm_results).cp1
	}
	if mmGetGRPCConn.funcGetGRPCConn != nil {
		return mmGetGRPCConn.funcGetGRPCConn()
	}
	mmGetGRPCConn.t.Fatalf("Unexpected call to ClientMock.GetGRPCConn.")
	return
}

// GetGRPCConnAfterCounter returns a count of finished ClientMock.GetGRPCConn invocations
func (mmGetGRPCConn *ClientMock) GetGRPCConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGRPCConn.afterGetGRPCConnCounter)
}

// GetGRPCConnBeforeCounter returns a count of ClientMock.GetGRPCConn invocations
func (mmGetGRPCConn *ClientMock) GetGRPCConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGRPCConn.beforeGetGRPCConnCounter)
}

// MinimockGetGRPCConnDone returns true if the count of the GetGRPCConn invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetGRPCConnDone() bool {
	for _, e := range m.GetGRPCConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGRPCConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGRPCConnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGRPCConn != nil && mm_atomic.LoadUint64(&m.afterGetGRPCConnCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetGRPCConnInspect logs each unmet expectation
func (m *ClientMock) MinimockGetGRPCConnInspect() {
	for _, e := range m.GetGRPCConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.GetGRPCConn")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetGRPCConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetGRPCConnCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetGRPCConn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGRPCConn != nil && mm_atomic.LoadUint64(&m.afterGetGRPCConnCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetGRPCConn")
	}
}

type mClientMockNotifyShutdown struct {
	mock               *ClientMock
	defaultExpectation *ClientMockNotifyShutdownExpectation
	expectations       []*ClientMockNotifyShutdownExpectation

	callArgs []*ClientMockNotifyShutdownParams
	mutex    sync.RWMutex
}

// ClientMockNotifyShutdownExpectation specifies expectation struct of the Client.NotifyShutdown
type ClientMockNotifyShutdownExpectation struct {
	mock   *ClientMock
	params *ClientMockNotifyShutdownParams

	Counter uint64
}

// ClientMockNotifyShutdownParams contains parameters of the Client.NotifyShutdown
type ClientMockNotifyShutdownParams struct {
	ctx         context.Context
	stopChannel chan<- struct {
	}
	waitForStateChange time.Duration
}

// Expect sets up expected params for Client.NotifyShutdown
func (mmNotifyShutdown *mClientMockNotifyShutdown) Expect(ctx context.Context, stopChannel chan<- struct {
}, waitForStateChange time.Duration) *mClientMockNotifyShutdown {
	if mmNotifyShutdown.mock.funcNotifyShutdown != nil {
		mmNotifyShutdown.mock.t.Fatalf("ClientMock.NotifyShutdown mock is already set by Set")
	}

	if mmNotifyShutdown.defaultExpectation == nil {
		mmNotifyShutdown.defaultExpectation = &ClientMockNotifyShutdownExpectation{}
	}

	mmNotifyShutdown.defaultExpectation.params = &ClientMockNotifyShutdownParams{ctx, stopChannel, waitForStateChange}
	for _, e := range mmNotifyShutdown.expectations {
		if minimock.Equal(e.params, mmNotifyShutdown.defaultExpectation.params) {
			mmNotifyShutdown.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmNotifyShutdown.defaultExpectation.params)
		}
	}

	return mmNotifyShutdown
}

// Inspect accepts an inspector function that has same arguments as the Client.NotifyShutdown
func (mmNotifyShutdown *mClientMockNotifyShutdown) Inspect(f func(ctx context.Context, stopChannel chan<- struct {
}, waitForStateChange time.Duration)) *mClientMockNotifyShutdown {
	if mmNotifyShutdown.mock.inspectFuncNotifyShutdown != nil {
		mmNotifyShutdown.mock.t.Fatalf("Inspect function is already set for ClientMock.NotifyShutdown")
	}

	mmNotifyShutdown.mock.inspectFuncNotifyShutdown = f

	return mmNotifyShutdown
}

// Return sets up results that will be returned by Client.NotifyShutdown
func (mmNotifyShutdown *mClientMockNotifyShutdown) Return() *ClientMock {
	if mmNotifyShutdown.mock.funcNotifyShutdown != nil {
		mmNotifyShutdown.mock.t.Fatalf("ClientMock.NotifyShutdown mock is already set by Set")
	}

	if mmNotifyShutdown.defaultExpectation == nil {
		mmNotifyShutdown.defaultExpectation = &ClientMockNotifyShutdownExpectation{mock: mmNotifyShutdown.mock}
	}

	return mmNotifyShutdown.mock
}

//Set uses given function f to mock the Client.NotifyShutdown method
func (mmNotifyShutdown *mClientMockNotifyShutdown) Set(f func(ctx context.Context, stopChannel chan<- struct {
}, waitForStateChange time.Duration)) *ClientMock {
	if mmNotifyShutdown.defaultExpectation != nil {
		mmNotifyShutdown.mock.t.Fatalf("Default expectation is already set for the Client.NotifyShutdown method")
	}

	if len(mmNotifyShutdown.expectations) > 0 {
		mmNotifyShutdown.mock.t.Fatalf("Some expectations are already set for the Client.NotifyShutdown method")
	}

	mmNotifyShutdown.mock.funcNotifyShutdown = f
	return mmNotifyShutdown.mock
}

// NotifyShutdown implements interfaces.Client
func (mmNotifyShutdown *ClientMock) NotifyShutdown(ctx context.Context, stopChannel chan<- struct {
}, waitForStateChange time.Duration) {
	mm_atomic.AddUint64(&mmNotifyShutdown.beforeNotifyShutdownCounter, 1)
	defer mm_atomic.AddUint64(&mmNotifyShutdown.afterNotifyShutdownCounter, 1)

	if mmNotifyShutdown.inspectFuncNotifyShutdown != nil {
		mmNotifyShutdown.inspectFuncNotifyShutdown(ctx, stopChannel, waitForStateChange)
	}

	mm_params := &ClientMockNotifyShutdownParams{ctx, stopChannel, waitForStateChange}

	// Record call args
	mmNotifyShutdown.NotifyShutdownMock.mutex.Lock()
	mmNotifyShutdown.NotifyShutdownMock.callArgs = append(mmNotifyShutdown.NotifyShutdownMock.callArgs, mm_params)
	mmNotifyShutdown.NotifyShutdownMock.mutex.Unlock()

	for _, e := range mmNotifyShutdown.NotifyShutdownMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmNotifyShutdown.NotifyShutdownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNotifyShutdown.NotifyShutdownMock.defaultExpectation.Counter, 1)
		mm_want := mmNotifyShutdown.NotifyShutdownMock.defaultExpectation.params
		mm_got := ClientMockNotifyShutdownParams{ctx, stopChannel, waitForStateChange}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmNotifyShutdown.t.Errorf("ClientMock.NotifyShutdown got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmNotifyShutdown.funcNotifyShutdown != nil {
		mmNotifyShutdown.funcNotifyShutdown(ctx, stopChannel, waitForStateChange)
		return
	}
	mmNotifyShutdown.t.Fatalf("Unexpected call to ClientMock.NotifyShutdown. %v %v %v", ctx, stopChannel, waitForStateChange)

}

// NotifyShutdownAfterCounter returns a count of finished ClientMock.NotifyShutdown invocations
func (mmNotifyShutdown *ClientMock) NotifyShutdownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNotifyShutdown.afterNotifyShutdownCounter)
}

// NotifyShutdownBeforeCounter returns a count of ClientMock.NotifyShutdown invocations
func (mmNotifyShutdown *ClientMock) NotifyShutdownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNotifyShutdown.beforeNotifyShutdownCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.NotifyShutdown.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmNotifyShutdown *mClientMockNotifyShutdown) Calls() []*ClientMockNotifyShutdownParams {
	mmNotifyShutdown.mutex.RLock()

	argCopy := make([]*ClientMockNotifyShutdownParams, len(mmNotifyShutdown.callArgs))
	copy(argCopy, mmNotifyShutdown.callArgs)

	mmNotifyShutdown.mutex.RUnlock()

	return argCopy
}

// MinimockNotifyShutdownDone returns true if the count of the NotifyShutdown invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockNotifyShutdownDone() bool {
	for _, e := range m.NotifyShutdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NotifyShutdownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNotifyShutdownCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNotifyShutdown != nil && mm_atomic.LoadUint64(&m.afterNotifyShutdownCounter) < 1 {
		return false
	}
	return true
}

// MinimockNotifyShutdownInspect logs each unmet expectation
func (m *ClientMock) MinimockNotifyShutdownInspect() {
	for _, e := range m.NotifyShutdownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.NotifyShutdown with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.NotifyShutdownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterNotifyShutdownCounter) < 1 {
		if m.NotifyShutdownMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.NotifyShutdown")
		} else {
			m.t.Errorf("Expected call to ClientMock.NotifyShutdown with params: %#v", *m.NotifyShutdownMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNotifyShutdown != nil && mm_atomic.LoadUint64(&m.afterNotifyShutdownCounter) < 1 {
		m.t.Error("Expected call to ClientMock.NotifyShutdown")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetGRPCConnInspect()

		m.MinimockNotifyShutdownInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetGRPCConnDone() &&
		m.MinimockNotifyShutdownDone()
}
